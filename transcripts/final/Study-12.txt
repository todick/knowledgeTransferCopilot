Timer.
Timer läuft.
Und dann bitte noch einmal auf Start Recording drücken.
Okay, alles klar.
Wollen wir mal bitte laut und deutlich reden.
Oh ja, machen wir mal größer.
Machen wir das mal hier hin.
Ja, ist gut.
Terminal.
Gut, das ist schon mal gut.
Dass es im Terminal läuft.
Gut.
Bist du schon mal mit SQL gearbeitet oder SQLite oder irgendwas?
Naja.
Ich auch nicht.
Nur das von BD.
Ja, das tatsächlich selbst was habe ich nicht gemacht.
Ne.
Nur das von BD.
Das hat er gesagt, das habe ich nicht gemacht.
Okay, bist du?
Äh, gerade bei dem zweiten.
Lassen wir es da erstmal auf, oder?
Ja, ja.
Also, es gibt dieses Main.
Und es kreiert eine Session.
Dann gibt es ein Welcome.
Gut.
Also das da verbindet sich im Prinzip nur mit der Datenbank.
Welcome Query müsste ja dieses Login oder neuer Account dann sein.
Was?
Dieses Welcome Query, das müsste ja der Login bzw.
neuer Account sein.
Das kann gut sein.
Ah ja, genau.
Ja, okay.
Entweder Login oder neuer Account.
Das ist auch zum Beispiel ganz nice in PyCharm.
Da kann man einfach auf irgendeine Funktionsteuerung klicken.
Und dann
Ah, genau, der fragt dann erstmal.
Ah, und dann
Was macht denn Post?
Kannst du draufgehen?
Aha.
Und dann Action.
Jede Option hat eine Action.
Und die ist
Was ist das?
Stellst du das falsch?
Das ist halt wie im Sopra einfach eine Execute.
Ah, das hier sind dann die Login Query und User Query.
Das sind dann diese Funktionen.
Ah, genau, hier sind die.
Login Query und hier User Query.
Und hier ist noch Logout.
Oh nice, das was Logout macht, das ist einfach wieder Welcome Anzeichen.
Aber gut, das ist halt
Man braucht im Prinzip niemanden auszuloggen, weil es ist halt
Das ist halt ein Statement Schienen.
Okay, Login.
Gut, der fragt dann die zwei Sachen ab.
Ja. Hier stellt er das Passwort und testet, ob es
Genau, prüft, vergleicht es dann.
Ah, genau.
Ah, nee, der
Was ist denn da Session hier?
Auf jeden Fall gibt er halt den
Loggt er sich dann praktisch mit dem Nutzer und Namen und Passwort bei der Datenbank ein.
Gehst du mal auf Login wieder?
Also das ganz normale Login, das ich aufrufe.
Hier das?
Ja. Ach, okay.
Ach so, ich verstehe.
Ah, ja, das ist die Datenbank.
Genau, die Datenbank ist halt das, was wir machen müssen.
Was steht denn dann hier?
Okay, genau, der pappt dann einfach None in das User rein und dann überprüft das If danach, ob ein User existiert.
Wenn ja, dann war es ja erfolgreich, und wenn nein, dann ist irgendwas falsch.
Wir müssen einfach probieren
Genau, wir müssen probieren, ob der gegebene User existiert.
Und ob das Passwort richtig ist.
Genau.
Und wenn ja, dann geben wir den User als Objekt zurück.
Genau.
Wo ist denn dann das User-Objekt?
Wo haben wir
Ja, hier.
Ja. Was ist denn User als Objekt?
Wo ist denn das User?
Steht das in der Beschreibung?
Ah, ja.
Das ist
Entry?
Gibt es nicht.
Nee.
Ah, nee, das ist dann im Model wahrscheinlich.
Ah, ja, da.
Ja. Was macht denn Colin?
Ich hab keine Ahnung.
Genau, frei für die Dokumentation.
Moment, ist das ein Dataframe?
Ja, nee.
Ja, da oben dieses SQL-Alchemy.
Da kommt das her.
Ach so, ja.
Das sieht schon ein bisschen aus.
Ja. Ja. Ja. Sieht gut aus.
Da ist ja unser User wieder.
Aber was ist denn das?
Was ist denn dann das, was hinten dran steht?
Keine Ahnung.
Decorative Table.
Ah, was?
Der Unterschied ist irgendwie, dass du bei dem einen, soweit ich das sehe, vorher alles deklarierst oder so.
Hier.
Und wenn du den Column-Command benutzt, dass du das dann irgendwie, die eine Spalte separat deklarierst und dann das irgendwie mappst.
Ach so.
Hm.
Bezieht sich das dann einfach auf die Spalten-Nummer?
Dass du quasi, wenn du zwei Objekte anfertigst, also zwei, drei Column-Objekte, dass du dann automatisch das erhöht bei jedem neuen Objekt?
Keine Ahnung.
Aber ich glaube, das hat was
Guck mal hier.
Decorative Base.
Ich glaube, das hat was damit zu tun.
Aber wo würde das dann
Da kann ich auch mal draufgehen.
Das ist ja auch eine Funktion.
Oh.
Das ist allerdings
Ja. Das ist immerhin nix Dekompilates, aber
Hallo, Kacke.
Ist das Dekompilates?
Hallo, Kacke.
Das ist eine Dokumentation.
Decorative Base.
Was ist denn ein deklaratives Mapping?
Keine Ahnung.
Da ist sowas oben.
Deklarative Table und Imperative Mapping.
Wir wollen ja irgendwie
Das wird's nicht.
Ok.
Top level introduction.
Das hört sich doch gut an.
Ist the typical way that Mappings are constructed in modelize.
Yeah.
It's not that easy to find a constructed, first constructed base.
Oh, da sind drunter die dort, die sind interessant.
Also irgendwie ist glaube ich die Idee, ich glaube das ist nicht so kompliziert.
Ich glaube die Idee ist einfach, dass das hier irgendwie so eine leere SQL-Klasse.
So ein Startpunkt.
Ja, genau.
Wo halt noch nichts drin steht.
Und der User wird dann immer so drangehört.
Genau.
Und das ist dann wahrscheinlich das mit dem Column-Command, was dann hier passiert.
Ich meine, das da erbt ja von dieser Base-Klasse.
Ich meine, ich kann mir halt vorstellen, dass das hier irgendwie eine Kurzform davon ist.
Oder dass es zumindest nlich ist.
Kann sein.
Dann erbt halt unser User.
Ja, das ist dann halt einfach eine Datenbank, wo die Dinge drin stehen.
Ich weiß aber auch ehrlich gesagt nicht, ob das so viel Sinn macht, uns da jetzt ekelig reinzulesen.
Bin ich auch gerade im Leben.
Ich weiß nicht, ob wir das überhaupt brauchen, ob wir das überhaupt verstehen müssen.
Ich finde es vielleicht höchstens noch interessant, wenn wir das vergleichen, also wenn wir da Passwort, Nutzernamen so vergleichen wollen, dann ist das ja Dat
Ja gut, in beidem ist das theoretisch hinterlegt, je nachdem, ob es
Nein, nein, nein.
Was macht denn das da?
Ausrufezeichen R.
Gute Frage.
Naja.
Ich würde vielleicht sagen, wir gucken jetzt mal hier so durch.
Und gucken, ob wir schon mal irgendwas machen können.
Weil ein paar von denen werden ja vielleicht nicht so schwer sein.
Zum Beispiel hier login.
Von wo wird denn das aufgerufen?
Das war von hier.
Und das, was das zurückgibt, ist halt ein User.
Das heißt, wir müssen
Wir sind innerhalb der Datenbank.
Wo kriegen wir denn die Daten innerhalb von unserer Datenbank?
Ah ja, das ist die Session.
Das ist die Session.
Wo kriegen wir denn die Daten innerhalb von unserer Datenbank?
Ah ja, das ist die Session.
Die Session ist praktisch unsere Datenbank.
Und da kriegen wir dann her praktisch
Da gucken wir dann, ob der angegebene Username, ob der da existiert.
Ja, und wenn es dann von dem User, den wir aus der Datenbank gefunden haben, das Passwort raus.
Oder den Passwort Hash.
Ja, ich denke mal eher
Ich würde noch vermuten, dass da ein Hash drin ist, aber wir müssen ja
Ich glaube auch, es war ein Hash.
Also
Die Frage ist halt, wie man mit dieser Session arbeitet.
Das ist mir im Moment noch nicht wirklich klar.
Ich weiß aber auch nicht, wo die überhaupt definiert ist.
Ja, da suchen wir am besten
Oh Gott.
Ach du Scheiße.
Damit haben wir nichts zu tun.
Am besten gucken wir, ob man nach der Session wo die ist.
Hier wird die erstellt, ja.
Das ist halt irgendwie ein
Engine.
Was ist ein Engine?
Keine Ahnung.
Mach mal den Port auf, vielleicht taucht die ja da irgendwie.
Okay, nee.
Using the Session.
Opening and Closing.
Das ist schon gemacht.
Queering.
Du weißt doch bestimmt, was wir für wollen.
Aber das ist doch die Engine.
Also im Code.
Ja, aber das da ist ja einfach nur
Das haben wir ja in dem Fall schon.
Ja, genau, genau.
Das heißt, wir haben hier
Haben wir dann schnell
Es ist gedeckt.
Untertitel der Amara.org-Community
Warte mal, was machen wir denn, was wollen wir denn dafür, wollen wir für
Ich würde sagen, wir haben ja den Username gegeben, das ist ja der, der eingetippt wurde.
Ja. Das heißt, wir brauchen dann für den Username, der eingetippt wurde, das User-Objekt.
Genau.
Ja, aber welches ist denn das dann?
Die zweite?
Ah, die Vier, das, guck mal.
Select UserFilterByName.
Ach, das
Ach, hier ist User in dem Fall dann als Klasse gemeint.
Vermutlich.
Also nicht irgendein User-Objekt, sondern wirklich einfach nur die Klasse, die angegeben ist, die du haben willst.
Hm, okay.
Ja, das macht Sinn.
Sollen wir das mal probieren?
Ach ja, stimmt.
Ja, queryForUserObjekts, ja.
Okay, das heißt, wir hätten dann hier, wie nennen wir das Ding denn?
User.
Select.
Nee.
Doch, Select.
Und dann, das Groß-User wird dann einfach nur der Typ quasi sein, der gewollt ist.
Ich verstehe gerade nicht, wo sich das hier auf die Session beruft.
Gut, ist dieses so mit, aber ehrlich gesagt, die Sonntags habe ich auch noch nicht gesehen.
Da wird dann wahrscheinlich diese Session fest dann füllen, diese ganzen Anfragen.
Vermutlich.
Select.
User.
Ah, das da sieht schon mal
Warte mal.
Heidschar weiß sowas doch normalerweise auch.
Select.
Vielleicht ist das auch
Ja. SelectUser.
Vielleicht muss ich es auch einfach mal fertig schreiben noch.
Name ist gleich
Okay, Heidschar ist schon mal nicht happy damit.
UnresolvedReferenceSelect.
Gut.
Na gut, dann haben wir die Session irgendwie nicht so richtig berücksichtigt.
Okay, und das Name.
Und das Name.
Und das Name.
Und das Name.
Und das Name.
Und das Name.
Okay, und das Name.
Sollen wir das einfach mal kurz probieren?
Ist das Name da ein Problem, was da drin steht?
Weil, also ich kenne das nur, dass rot ist, auch wenn es komplett rot geschrieben ist, heißt das einfach, da ist irgendwas nicht richtig importiert.
Okay, ne, scheinbar ist Heidschar nicht.
Ich probiere das jetzt einfach mal.
Genau.
Äh, Moment, wir wollen uns einloggen hier.
Name.
Session has no attribute select.
Okay, also ist das da schon mal kaputt.
Aber wir sind immerhin schon mal im Kontrollverlust an die richtige Stelle gekommen.
Das stimmt.
Und wir sind immerhin schon mal bis hierhin gekommen.
Hm.
Äh.
Was ist denn das da?
Das verstehe ich gerade nicht.
Jetzt mal, es tut es selber nur, dass es den nicht Nenutzer mit dem Namen rausgibt, sondern alle Nenutzer, die in der Session enthalten sind.
Das kann auch sein.
Gucken wir mal, ob das funktioniert.
Ja, da kann man aus der Liste dann theoretisch über die Liste drübergehen und dann da die Namen abgleichen, dass man den gefunden hat, den man braucht.
Ja, was ist denn dann dieses Statement?
Ist gleich.
Hä?
Ist das gleich?
Ein Context Manager.
Oh Gott.
Ach Leute, das ist das von oben, okay.
Ach so.
Das ist, das hängt zusammen.
Okay, das Kommando zurück, wir brauchen es doch wieder.
Select User.
Filter.
Bar.
Name.
Gleich.
Und Haskell.
Session hast du doch eben wieder vorstehen gehabt.
Ja, aber das war er doch auch nicht happy damit.
Das stimmt, aber jetzt ist er auch nicht happy.
Wobei ich dann jetzt nicht mehr weiß, was das Zweite tut, weil ich jetzt
Meine Ideen widersprechen sich da gerade ein bisschen.
Ja, gleich das Problem wie vorhin.
Hast du da irgendwo eine Liste, eine Dokumentation, eine Liste mit den ganzen anderen Routen, die es hat?
Das Session Objekt?
Mhm.
Bestimmt.
Äh.
Wenn es jetzt sagt, Select ist nicht verfügbar, dann können wir mal gucken, was verfügbar ist.
Dann ist da ein bisschen Durchfahrt.
This is a fusing session.
Aber nee, das muss doch dann eigentlich das da sein.
Ja, eigentlich
Müssen wir das vielleicht importieren?
Mhm.
Dann probieren wir mal.
Ja, das ist gut.
Hey.
Man muss es einfach importieren.
Wow.
Okay, dann haben wir jetzt
Moment mal.
Haben wir irgendwie
Ach nee, ich glaube, wir brauchen schon einen new user, um das da ausprobieren zu können.
Das stimmt.
Ja. Aber hey, unser Programm ist mal ohne Error durchgelaufen.
Ich würde es
Wobei, da ist glaube ich überall to do dran, oder?
Ja. Aber okay.
Okay, das heißt, wir brauchen jetzt new user.
Moment, da steht ja dann auch hier drin, adding new or existing items.
Aber dann müssen wir ja hier noch ein Passwort einbauen.
Wäre dann praktisch
New user ist gleich
New user
Haben wir ein user-Objekt?
Ja. Ja, das war in
Models, ja.
Genau, Models, glaube ich.
Ah, id, name, password, entries.
Das sind dann
Die ganzen Einzelpasswörter für die einzelnen Anwendungen?
Stimmt, klar.
Also die Liste mit den Passworteinträgen?
Stimmt, natürlich.
Und das andere Passwort ist dann der für den
Das ist dann erstmal leer.
Passwortmanager-Account, genau.
Name
Stopp mal, id erstmal.
Geben wir dem erstmal die id null und kümmern uns gleich darum, dass jeder User eine neue id bekommt.
Okay, falsch angefertigt.
Nicht, dass ich hier Leerzeichen dazwischen mache.
Name
Passwort
Gleich Passwort.
Und
Entries
Gleich leer.
Und jetzt?
Müssen wir das hier einbauen.
Genau.
Da ist ja noch session.addNull.
Die Frage ist halt, was das da zurückgibt.
Ah, okay.
Die Frage ist halt, was das da zurückgibt.
Ja. Nix.
Es gibt none zurück.
Wie kriegen wir es dann hin zu wissen, ob der das schafft oder nicht?
Wir müssen ja hier success oder not success zurückgeben.
Wieso müssen wir das?
Hier.
True, if no user with the given name has already existed and the new user has been added.
Ah, dann müssen wir das selber abfragen, manuell.
Vielleicht ist das, was wir machen bei Logging, einfach nach dem Nutzer suchen, ob der bereits existiert mit dem Namen.
Beziehungsweise der id.
So ungefr.
Die id müssen wir jetzt mal neu zuweisen, aber der Name
Also die id sucht sich der Nutzer ja wahrscheinlich nicht aus.
Okay, dann nur mit dem Namen.
Kopieren wir das da mal.
Okay, so.
Name gleich.
Name.
Und jetzt machen wir if user.
Ist das dann so, dass der das dann auch so leer zurückgibt?
Ja. Not müsste das entfalten sein.
Stimmt, ja.
Boah, ich konnte helfen.
New user.
Sowas?
Ja, würde ich sagen.
Klingt vernünftig.
Probieren wir das mal.
Okay, das ist schon mal
New user.
Soll ich jetzt zuerst Logging testen?
Genau, test mal Logging.
Pass mal hoch.
Oh, okay.
Ich probiere mal, wie ich jetzt
Moment mal.
New user.
Ah, das ist gut.
Aber warum geht es dann unten?
Wart mal, returnen wir bei Logging überhaupt schon was?
Müssen wir ja nicht.
Nee, ich meine, vielleicht ist das der Grund, warum Logging gerade eher
Weil der nicht true zurückgibt, dann konnte das da gerade nicht klappen.
Weil das mit dem
Stimmt, wir müssen den User zurückgeben.
Stimmt.
Genau, wir müssen da das Pass mal hoch schicken.
Wir haben da irgendwie mittendrin aufgehört.
Okay, aber dann funktioniert es ja soweit schon mal.
Genau.
Und vor allem sollte man das Pass vielleicht wegmachen.
Dann stirbt es auch, wenn es nicht fertig so ist.
Okay, also soweit funktioniert dann jetzt erstmal alles, was wir gemacht haben.
Genau.
Okay, 
Das heißt, wir müssen
Wir müssen jetzt das Passwort checken.
Die Frage ist dieses User-Objekt.
Ist das dann jetzt eine Liste mit allen Usern, oder ist das der User mit dem Namen Francesco?
Das ist der
Stopp mal.
Erstmal muss hier Name gleich nehmen hin.
Genau.
Das war ja vorhin der Test.
Okay, und jetzt müssen wir überprüfen, ob das Passwort
gleich ist
Yes!
Yes!
Return User.
Genau.
Genau.
Wollen wir nochmal testen?
Jetzt sollte ja Login auch laufen, oder?
Theoretisch.
Meinst du, der merkt sich Dinge?
Ich glaube nicht, ehrlich gesagt.
What?
Okay, das ist eine Liste dann.
Das ist User.
Dann kannst du nicht
User.Passwort, das ist deine Liste.
Die musst du erstmal entpacken.
Was?
Nein, hier dieses User.Passwort.
Aber das ist eine Liste, weil hier steht ja auch
Okay, stand eben, dass das eine Liste mit Usern zurückgibt.
Oh!
Da musst du dann erstmal irgendwie dir deinen User-Objekt wieder rausholen.
Und da kann man dann noch ein Passwort draufmachen.
Irgit, warte mal.
Jetzt können wir ja eigentlich auch
Warte mal, wo waren das, was ich vorhin gemacht hatte?
Das war
Nein.
Hier, querying.
Genau.
Da steht es auf List of User Objects.
Ja, aber ist das dann nicht einfach?
Warte mal, jetzt wo das andere funktioniert
Das findet er schon mal komisch.
Ah ne, das geht schon mal nicht.
Ja, okay.
User ist gleich
Scalers
State
Und
Punkt
Gibt es sowas wie Handler?
Ja. Handler.
Handler.
Handler.
Handler.
Handler.
Punkt
Gibt es sowas wie Head oder Tail oder First oder sowas?
Muss mal gucken, das gibt es bestimmt.
Okay, also
User
Login
Ja!
Logout
Funktioniert!
Jawohl.
Nice.
Gut, das heißt, das da geht
Also weg damit.
Und das da geht.
Genau.
Was ist das denn?
Extensive String
Ach so, Padding.
Das ist
Das klingt
Das klingt jetzt erstmal auch nicht so schwierig.
Ne.
Ich glaube nicht.
Ich weiß nicht, wie es in Python ist, aber in anderen Sprachen ist das nicht so schlimm.
Dann machen wir das mal mit einer While-Schleife.
While
Länge von Text
Echt kleiner als Total Length?
Das ist ja mal
Ich vermute ja mal, dass das das ist, was der haben
Die Länge, die der haben will, oder?
Ja, genau.
Genau, how long the final string should be.
Machen wir das Pass weg, bevor ich das wieder vergesse und komische Sachen passieren.
Okay, 
Text.append
Wertzeichen!
Super.
Fertig.
Jo.
Ob das funktioniert, werden wir zu gegebener Zeit herausfinden.
Ja. Da steht kein Tribut drin, also kommt das auch weg.
Okay, jetzt kommt das Interessante.
Wie viel Zeit haben wir eigentlich noch?
Keine Ahnung.
Wie viele Funktionen haben wir denn noch zu machen?
Ey, das sind gar nicht mal so unfassbar viele.
Ich würde mit addEntry anfangen.
Ich glaube, das macht am besten die Grundlagen für den Rest.
Und das können wir sonst nicht testen.
Da wir keine Standard-Datenbank haben, können wir nicht Dinge testen, solange wir nicht Dinge hinzufügen können.
Wir kriegen die Session, wir kriegen den User, wir kriegen den Namen, Info und Passwort von der Entry.
Der User hat ja eine Liste, oder?
Wo seine Infos drinstehen.
Ja, genau.
Das heißt, finden wir erst mal heraus, gibt es so etwas wie User.addEntry?
Nee.
Aber es gibt Entries und dann kann man einfach erkennen.
Das ist schon mal gut.
Das heißt, wir müssen erst mal ein Entry noch erstellen, ein Entry-Objekt.
Stimmt, ja.
Wo ist das?
In Model?
Das war aber User, das müsste dann auch in Models sein.
Hast du noch auf?
Ja, ja, klar.
Aber das ist dann einfach
So?
Mhm.
Ja, okay.
Irgendwie solltet ihr mir doch auch die Argumente mal anzeigen.
Vielleicht drüber gehen mit der Masche?
Nee, okay.
Split and move right.
Entry.
Warum existiert hier kein Konstruktor?
Ah, bevor wir es vergessen.
Wir müssen uns irgendwann mal noch darum kümmern, dass die User nicht alle 0 als ID bekommen.
Stimmt.
Ich sag mal, ich hätte eine spontane Lösung, aber die ist nicht im Sinne der Aufgabe.
Und zwar
Random.
Jawohl, das machen wir.
Ein paar Mal wird es funktionieren, nur irgendwann dann nicht mehr.
Das klingt nur noch sauer.
Das wird relativ lange funktionieren scheinbar.
Vermutlich schon.
Okay, ich glaube, das wäre es.
Entschuldige mich, Tata.
So glatt, random importieren.
Ja, okay.
Problem gelöst.
Gut, wir haben die Session.
Wir müssen die Entry machen.
Was waren da die Argumente?
Ich vermute mal, dass das einfach die, die hier sind, auch wenn ich verwirrt davon bin, dass es gerade keinen Konstruktor gibt.
Keine Ahnung, tipp einfach die Dinger mal ein und mal gucken, was passiert.
Entry für die Entry.
Dann geben wir der Entry erstmal ID 1 und kümmern uns später darüber.
Warte, wir haben doch den Current User.
Achso, eine Idee.
Jeder User kriegt eine neue ID.
Wo ist denn User?
Das ist doch auch hier.
Ja, der hat eine ID.
Aber wenn ich das da so mache, dann sollte der mir doch hier auch Typings geben können, oder?
Keine Ahnung, ich habe das noch nie gemacht.
Ja, dann sieht er sogar, dass das ein User ist.
Fügen wir die mal hier ein, dann ist es einfacher, die Dinger zu programmieren.
Ich glaube, das ist da, , keine Ahnung.
Ja, komm, egal, das ist ein User.
Current User, IP.
Das dürften ja alles Strings sein.
User.
Was ist denn der Relationship?
Was ist das denn?
Ah, das ist einfach nur eben sein Name.
Gut, und die anderen drei sind ja gegeben als Argumente.
Okay, und jetzt müssen wir das irgendwie in die Datenbank einfliegen.
Ach stimmt, das ist wieder gar nicht im Nutzerdeal.
Wie fügen wir das jetzt in die Datenbank ein?
Wir haben hier den User.
Ah, nee, wir müssen das praktisch in das User-Objekt in die Datenbank einfügen.
Das heißt, wir müssen uns zuerst den User aus der Datenbank ziehen und dem dann das Objekt geben in seine Entries und den dann wieder einbauen.
Macht das Sinn?
Klingt sinnvoll, ja.
Wobei, wenn du den einbaust, ist das, wenn du das Objekt hier rausziehst und dann von dem Objektenwert änderst, müsste das nicht automatisch übernommen werden?
Das ist halt die Frage, wie dynamisch das funktioniert.
Ah nee, warte mal, hier habt ihr euch doch vorhin was gesehen von Modifying-Entries.
Irgendwo hatte ich das gesehen.
Session, nee.
Google-Integrations-SQL-Key-Modifying-Entry.
To update a row entry.
Update.
Boah, das ist ein Befehl.
Ah nee, guck mal, hier.
User.soundso und dann Session.commit.
Kann es sein, dass man hier auch Session.commit machen muss, nachdem man Dinge hinzufügt?
Kann sein.
Kannst es ja mal hinschreiben, rauszuholen.
Ich bezweifle, dass es was kaputt macht, wenn man es vielleicht nicht richtig hinschreibt.
Place an object into Session.
Schreiben wir es einfach mal hin.
Ja. Aber besser als das wieder zu suchen.
Wir brauchen ja auch nicht mit Login brauchen wir das nicht, oder?
Nee, nee, der sucht immer.
Das heißt, wir wollen jetzt hier, nee, das war das andere.
User.
Nee, stopp mal, wir müssen den ja erstmal aus der Datenbank rausziehen.
Kannst du das machen wie bei Login, theoretisch.
Da hatten wir den ja auch rausgezogen.