Das war ein Premium-Feature-Teil. Ganz tolle Möglichkeiten. So ist die zweite Bischofshalle. Kannst du ein bisschen was zurückschreiben? Ich darf nicht antworten. Ich werde jetzt nicht googeln, wie man den scheiß Bischof anbetätigt. Das war das Erste, oder? Das Zweite. Session.query Und dann in Klammern was, wo wir hinwollen. Session gleich SomeSession. Ah ne, guck mal, das ist nur Query sogar. Ah ne, SomeSession.query und dann UserAddress. Ok, da müssen wir aber... Ok, ist nicht. Session.query Ne, da müssen wir... gleich Session.query Und dann haben wir da schon unser schönes Model da in unserem PDF drin. Ja. Wo man User-Band drauf, oder? Äh... Ja, aber haben wir... Aber... Ok, ganz kurz Verwirrung. Weil... Hast du was? Achso, nee, nicht verwirrung. Ich hab irgendwie gedacht, dass du hier konkrete Parameter reinzumeißen musst. Aber du bekommst dann einfach die... also die User-Tabelle raus. Genau, denke ich mal. Wenn ich mich jetzt recht entsinne, dann müssen wir doch auch hintendran jetzt einfach dann... hängen können, oder? Ja, ich meine, das geht in der Art. Denkst du, wir müssen auf SQL-Injection so aufpassen, oder können wir das einfach aufjodeln? Also, ich meine, wenn wir hätten drauf... Also... Dann wird's in der Spezifikation. Das Optional kostet extra. Ich meine, man... In Bedenken muss man extra bezahlt werden. Ja, oder? Achso, da hinten hat das ja irgendwie gestanden mit dem wer, oder? Da, ja, ja, User-Tabelle. Ok, da müssen wir mal User. Oder? Äh... Die Frage ist, ist jetzt das Queue das Ding, worauf wir arbeiten, oder das Queue von vorne? Aber eigentlich Query Punkt... Ne, ich glaube, das ist was anderes. Dann lass das besser in zwei Zeilen aufteilen. Also dann... Expression... Statement, das ist ok. Queue Punkt... Ne. Ich möchte eine kleine... Ja... Queue Punkt... So, Parameter kriegen wir rein. Name... Was war das C da drin? Ähm... Da bin ich mir jetzt selbst nicht sicher. Vielleicht wenn du verschiedene... Hm. Können wir den Parallel noch weglassen? Probiere es mal aus. Ok, ich meine... Unreserved Reference Ware, ok, das kennt das Ware nicht. Also, jetzt einfach mal so visuelle Unterschiede. Da ist es erstmal in Klammern gepackt. Und das Ware ist ja dann auch etwas, was spezifiziert, worauf du eine andere Operation anwendest. Also hier ist es... Du willst irgendwas deleten. Wo? An der Stelle? Das bezieht sich ja da vorne drauf. Stimmt, stimmt, stimmt. Was war denn da vorne dran? Ist das ein Get oder sowas? Ha! SQL... Ja, so kann ich das auch schreiben. Was ist denn da drin? Das Access-Gerät ist was drin. Ne, ne, ne, ne. Hier steht nichts. Stand da nicht irgendwas auf einer der ersten Seiten zu? Ich glaube nicht. Von Get. Können wir mal probieren. Gehen wir mal nach oben und gucken mal, ob wir mit Get oder einfach... Gerät. Gerät. Äh, Pipe-Method. Das sieht alles scheiße aus, Hilfe. Warum haben die so ein beschissenes D&D-Logo? Äh... Insert, das ist... Auch noch Inserts da. Da hast du auch noch Insert gesucht. Hört sich clever an. Ähm... Wenn wir zu Get sind, kriegen wir doch ein Constructed Query Directing. Können wir noch mal auf Query gehen? Ja, das... Ist das nicht die gleiche Seite? Ich glaube nicht. Das ist die Query-API. Ja, aber die da vorne auch. Ach ja, das war's. Dann gucken wir mal, wenn was. Get. Get hört sich sehr vernünftig an. Get 5. Ach so. Ich glaube, das ist auch... Ich glaube, 5 holt... Okay, das ist dann der Key. Nee, guck mal da, Get ID 5, Version ID 10. Das ist der Key hier. Aber hier können wir dann auch spezifizieren, wenn wir irgendwas haben wollen, das nicht... Waren User unique vom Namen her? Nein, nur ID. Oder geh noch mal in die PDF. Aber ich meine... ID war so blau unterlegt. Ich würde das jetzt mal so interpretieren. Okay, Name ist dann nicht unique. Okay, dann müssen wir nicht querien nach Name und dann gucken, dass das Passwort von einem der Leute passt. Ja, genau. Also am besten halt einfach ein And. Oder ist einfach ein Join. Nicht ein Join, aber halt ein Bullseye. Okay. Oder beziehungsweise wir... Ich meine, wir... Okay, wenn wir das so machen, wir holen uns die ID, also Get... Also holen uns die ID an der Stelle, also where Name equals den Name, den wir als Eingabe bekommen und das Passwort. Ich meine, wenn wir eine passende ID finden, heißt das ja im Prinzip, wir haben einen User, also entweder einen User in der Database gefunden, für den halt Name und Passwort... Oder halt nicht. Na gut, dann müssen wir... Dann machen wir da auch mal Query drauf auf Name und Passwort. Wenn es uns ein Objekt zurückschmeißt, dann gut. Dann existiert es nicht, dann kannst du es ja nicht erzeugen. Und ansonsten erzeugen wir den Adding und Return True. Dann brauchen wir die ID ja nicht direkt, oder? Das ist wahrscheinlich richtig. Die ID wird ja, glaube ich, automatisch erzeugt dann von diesen... Kostet es so an? Ich habe so Angst. Ich denke, die ganze Zeit machst du halt komplett was falsch, oder? Vielleicht hat es Aufmerksamkeit, also... Ja, wir werden durchgefallen. Wenn wir das benutzen, seid ihr durchgefallen. Ja gut, dann... Query... Gibt es was wie ein Select? Wie im Normalen? Nee, your name is unique. Da! Given name does not already exist. Okay... Das ist wieder ambiguous. Nicht unsere Schuld. Das reißt sich gerade so zusammen. Das kann es nicht werden. Keine Chance. Keine Chance. Einfach eine angefallene Methode. Da müssen wir wirklich nur noch einen Name suchen. Wenn der Name da ist, können wir einfach das Objekt erzeugen und reinschmeißen. Passwort ist egal. Nämlich spezifiziert. Wenn da alle lolol als Passwort nehmen, dann ist es nicht unser Problem. Das ist richtig. Okay, aber dann müssen wir noch rausfinden, wie eine Query funktioniert. Irgendwann erkenne ich SQLAlchemy QueryExample oder so. Hä? Gibt es ein Select? Wie in normalem SQL? Ich glaube, das Select ist doch das, was wir gerade machen. Session.querySelectUser Ja, weil User ist hier die Tabelle, in der wir arbeiten. Und mit Select könntest du ja auch... Form ist das, sorry. Beginner-Tutorial-Example. Das ist unser Niveau. Das ist es auch. Es ist ja nicht mehr falsch. Hurra. Tables.data.metadata.tables Wie machen die das? Ah, die machen einfach db.table. Okay, gut. Weil der wird ja erzeugt. Das ist eine etwas andere Methode. Eine andere Methode. Das funktioniert bestimmt beides. Damit ist Select. Ja. Hurra. Also machen wir halt einfach darauf, die Query sollte ja funktionieren trotzdem. Dann machen wir mal q.select. Erstmal noch select a name. Äh, ja. Den müsstest du eigentlich filtern brauchen, oder? Aber das können wir doch schon einfach mit einem where und einem rotor machen, oder? Genau, filtern. Also ob das Tuple, was wir zurückbekommen, dann der ist, wollen wir nachher gucken. Achso. Mach mal ganz langsam. Können wir uns mal anschauen, wie das Objekt dann auch aussieht. Ja, clever. Wir sind ein bisschen schlau. Eines auf dem anderen. Wir haben gesagt, ihr seid schlau. Wahnsinnig. Okay, select. Wie? Nee, nicht id, name, oder? Ja, stimmt. q.name. Ich weiß nicht. q.name equals name. Ob nichts unterkringelt? Wenn es noch nichts unterkringelt, würdest du es nochmal sagen? Jetzt geht es wieder. Okay. Jetzt steht im Idealfall irgendwas in unserem S drin. Jetzt müssen wir nur noch überprüfen, ob es B ist, oder nicht. Sollen wir mal was probieren? Es bleiben da keine Fehler drin. Sehr gut. Okay, wie starten wir das dann? Normalerweise geht einfach F5, oder oben der Start. Ich finde das einfach F5. Okay, dann machen wir New User. Einen geben wir doch. Dann nenne ich Hans Peter. Hans? Peter? Passwort ist lollol. Da gibt es einen Fehler. Query object has no attribute. Select. Gut zu wissen. Interessant. Müssen wir das Query machen? Können wir das auch schön machen? Also dieses Division Object. Das ist ja eben ein Table, den die geladen haben. Ja. Existiert das vielleicht schon? Ist es dieses Object, was wir da reinkriegen? Die Session? Nee, Session ist was anderes. Ähm... Das ist ja Zeug, oder? Da ist ein Metadata jetzt. Das sieht mich an wie Metadata. Am Ende hat SQLAlchemy einfach so eine Funktion, in die man ein paar Parameter reingeben kann, um zu überprüfen, ob der irgendwo schon in der Tabelle existiert. Wir machen uns hier gerade total vieles egal. Ich glaube auch. Es kann sein, dass wir diese Scheißquery gar nicht brauchen. Können wir... Lass es probieren. Dann brauchen wir noch ein From. Was ist diese Session Nummer? Create Session Engine. Session Engine. Die gibt uns diese ORM-Session. Die hat voll viele Parameter. Existiert dieses Ding überhaupt schon? Ja, das Create Session wird ja ganz normal anfangen. Ich meine, die Datenbank existiert aber schon. Das ist jetzt nicht das Problem. Autocomment Info. Info Queries. Ich meine, wir können ja nachschauen, ob irgendwo die entsprechenden Tabellen erstellt werden. Weil gesehen habe ich es ehrlich gesagt noch nicht. ORM-Session eingeben. Ich glaube, das ist einfach eine Partei, die irgendwie abfliegt, oder? Wo soll das sein? Test.db. Ja, okay. Ah, yes, readable. Da ist noch was drin. UserID, Integer. Ja, gut, passt. Readable. Hier ist nochmal ORM-Session. Das ist, denke ich, auch viel zu kompliziert. Wahrscheinlich. Ich kann es nicht im Blick rüber sehen. Wäre ich auch falsch. Gut. Ich gehe jetzt nur auf dem Stuhl. Session. Begin Session. Da ist noch was drin. Tracking. Ach, das sieht doch gar nicht so scheiße aus. Ich glaube, wir kriegen gleich wieder das Tutorial dadurch, dass die so einfach sind. Wahrscheinlich am schnellsten. Yeah, that would be sad. Ja. We will create an object. We will create objects. Simple select. Okay, Session, das ist das, was wir haben. Okay, dann ist es select. User, where, username. Okay. Die Frage ist, wo kommt die Session da drin vor? Das ist nur Statement. Und du callst dann doch auf die Session, callst du die Scheiße drauf, oder? Ah! Ah! Clever. Du erzeugst erst mal die Extraction und danach callst du das. Wie SQL. Voll easy. WD hat sich gelohnt. Wenn man den letzten Teil geschwänzt hat, ja. Okay, also wir machen erst mal unser Statement. Ja. Ich meine, wir haben ja schon angefangen. Fertig, oder? Wenn wir nicht auf Session scrollen. Ja, halt, einfach. SCC gleich select. Nebenwärts großgeschrieben, hier hab ich großgeschrieben, oder? Wahrscheinlich. Also da ist es klein geschrieben, aber ich weiß nicht. Nebenwärts großgeschrieben. Ah, stimmt. Stimmt. Warte, häng ich gerade? Ich häng gerade, ich häng gerade, ich häng gerade. Ich glaube... Ich meine, es ist ja... Ja, guck mal, hier ist das Table... Es ist im Prinzip egal, was wir selecten. Wir können einfach ein User selecten. Es geht uns ja nur darum, dass wir irgendwas zurückbekommen. Also schmeißt ihr einfach selectUser rein und dann machen wir in Spezifikationen eigentlich genau das gleiche wie da. User.Name und dann equals dem Namen, den wir als Eingabe in unsere Funktion bekommen. Das ist zwar eigentlich 1 zu 1, das, was wir wollen. Dann ist select ein bisschen anders, oder? Meinst du? Wenn du da unten bist, siehst du das Ding, selectUserAccountId, blablabla, das ist schon richtig. Ja. Aber hier haben wir nur User drinstehen, zum Beispiel. Das hier ist ja das SQL Query. Also so verstehe ich das. Und User ist sozusagen das Objekt. User besteht dann aus ID, Name und Fullname. Aber guck mal, der UserAccount ist hier im Front drin. Das ist doch wahrscheinlich der hier, oder? Ähm, nee. Wait. Kann es nicht sein, dass das selectObject einfach ein bisschen anders funktioniert? Da auch. Da steht dann selectAddress. Und dann .join auf address.user. Where user.name gleich sendi. Soll ich probieren? Ja. Also ich mach das erstmal Version 1, weil dann müsste das hier dann da Name, nee, User. User. SelectUser, where user.name gleich Name gleich, nee. Ja, okay. Select hier. Wir müssen immer noch gleich importieren. Ist das nicht importiert in der Datei? Wahrscheinlich nicht. Nee. Nee. Reinder. Reinder. Warum hängt da das S rum? Ah, das ist wirklich ein S. Ja, das ist ja klar. Ja, ja, ja, ja. Okay. Jetzt meckert das da noch rum. Ja, es ist hier nur gelb unterstrichen. Union column got bool instead. Achso, ähm. Das ist dann so ein in... Gut, da unten ist auch das .where. Ist gleich geregelt. Das ist richtig. Also ich hoffe mal, das funktioniert dann noch. Nicht ernstlos. Nachher beim Testen. Warum? Ich hab doch nichts getan. Session. Scalars. Okay, dann machen wir Session.Scalars. Das sollte funktionieren. Wir machen print. Session. Scalars. Scalars. Sollte aber eigentlich wahrscheinlich... Nee, wir haben nicht Session, oder? Doch, wir haben Session. Session, ja. Hab ich das falsch geschrieben? Warum ist das rot-weiß? Session.Scalars.