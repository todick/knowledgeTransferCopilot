Läuft jetzt. So, als erstes werde ich mal das Assignment lesen, denke ich. Zumindestens mal kurz. Ja, ich bin am lesen. Ein Sekunde. Aha. Okay. Ich denke mal, das hier ist quasi das Datenbankformat. Ohne, dass ich es bei jetzt genau durchlesen will. Okay. Machen wir mal den Code rein. Vielleicht beim Mail anfangen. Aber hier ist ja nichts mit ToDo, also muss ich das nicht machen. Okay. Ich muss ja nur Dinge mit ToDo machen. Okay. Hier ist ausgefüllt. Hier ist auch erstmal alles ausgefüllt. Okay. Jetzt muss ich nur die Datenbank machen. Okay. Sieht gut aus. Also, Datenbank. Das ist wohl die einfachste Methode. Die logischste. Also denke ich mal, das Hash vom Passwort. True. Return true, if no user with the given name already existed. And the user has been created. Okay. Checken, ob der User existiert. Ist natürlich die Frage. How? Cooles Suggestion, I guess. Der andere Komplettknopf ist bei meinem. Ist das Session-Ding was, was von euch kommt? Oder aus einer Library? Also, das ist wie... Wie navigiert man denn irgendwohin? Sprich nicht, lass! Model. Ah, ja, ja, ja, ja. Hier sind User-Dinge. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Hier sind keine Datenbank-Dinge. Eine Option. Eine Query. Warum kommt die Datenbank her? User von Entry Name. Add Entry Query. Muss man diese Methoden eventuell hier sogar verwenden? Ne, man hat ja Namen und Dings schon gegeben. Ich frag mich, wo hier grad die Ergänzungen kommen. Dieses Query. Ist das hier drin? Ne. Hä? Aber woher kommt denn der Kram? Woher kommt denn Session? Steht das bestimmt irgendwo hier, wo ich nicht hingeguckt hab. Ich könnte ja jetzt einfach schon interact with the database. Aber wo ist denn die Database genauer geschrieben? Hm. I guess ich bin doof. Lassen wir das einfach mal so. Query nach einem User und filter dann den User Name. Ist das mit dem Name so? Ja, Name. Sieht gut aus. Und dann das Name. Wenn der existiert. Sagen wir mal. First soll der eigentlich sagen, wenn der existiert. Dann wollen wir eigentlich hier noch Dinge tun. Eigentlich nur im else-Fall. Bevor wir returnen, denke ich mal. So. Geht auf Google, wird schon schlauer zu sein. Ich google jetzt. Database. Ah, ja. Irgendwo hat in dem Ding irgendwas zu PySQL oder sowas gestanden. Hab ich doch vorhin gelesen. SQLite Preview. Das ist dann bestimmt SQLite. Okay. Command execute. Aber hier kann man ja nicht querien. Wie kommt das auf query? Query SQLite 3.5. Ich müsste hier niemals so ein Kram machen. Ich mach da irgendwas falsch. Warum kann man hier nicht drauf drücken? Um dahin zu kommen, wo es herkommt. dbnewser Ich bin so verwirrt. dbcreate-engine db-sql-alchemy Ist das hier irgendwo in den Includes? Okay, dann. Weiter googeln. alchemy-query Ja, okay. Query scheint zu existieren. Dann vertrauen wir mal, was Copyright hier draus gemacht hat. Auch wenn es unterkringelt wird. Query Returned entsteht First Diese First Funktion. Also nach meinem Nach meinem Denken wäre das jetzt. Such alle User. Warum steht hier denn überhaupt User? Das ist doch schon sass. Weil das eine Klasse ist. Zu wenig Wissen. I guess we can do this. Okay. Okay. Okay. I guess man kann das hier dann so da rein machen. Ja, I guess. User und dann Filter und dann Username nehmen. Ah, uff. Mein Kopf ist dumm. Das Ding ist schon richtig. Mein Kopf hat es genau anders rumgedacht. Okay, für den Fall, dass wir noch keinen User haben. In meinem Wim ist es anders rum. Dann machen wir Add User Name und Password. Okay. Dann habe ich mich nur zu stark gestellt. Zumindest ist es auch kein Fehler mehr. Lassen wir es einfach mal so. Login. Checks whether a user with a given name or a password exists. Okay. The user object, if user exists, can be logged in as none. Okay. Dann können wir auch wieder so Ach, ich brauche ja keine kleinen Namen. Session Query User Filter Username Password Return Session User Filter Man kann das wahrscheinlich einfach so returnen, weil das sonst none ist, I guess. Kann ich aber gleich noch googeln. SQL Alchemy First One Hier link. So. Wo steht, was es returnt? Wie kann man denn suchen? Auf Linux Ding Ah, unten um das Suchding. Ja, das wollen wir. Okay. None of the result does not contain any rows. Also sollte das passen. Okay. Add an entry to the database. DB Session object. The user who is currently logged in. Name Info Warum haben wir Info? Was ist hier auf dem User? Hä? Die Entry-Info Ah, Entry Entry Okay. False, if there is already an entry with the name of the current user. In this case nothing is added. Truth, there is no entry. Das heißt, ich muss mir eigentlich Ich muss mir eigentlich erst mal den User abspeichern. Mit diesen Okay. Jetzt sage ich if Jetzt ist die Frage, wie ich mit dem User weitermache. User entries Ah, User ist jetzt ein Objekt von dieser Klasse hier. Okay. Okay. Okay. Okay. Vielleicht weiß der Copilot es weiter. Oh ja, perfekt. Filter EntryName Aber EntryName stimmt nicht. Aber was ist die richtige? Doch. Name Aber was ist Info jetzt? Ah, Info ist wahrscheinlich Wahrscheinlich ein ganzes Ding. Okay. Name ist ja ein Entry von Name. Okay, Copilot ist definitiv schon schlauer als ich. Okay, in dem Fall return wir False. Stimmt. Und im anderen Fall Okay. Fügen wir das Entry an und sagen Delete Entry Deletes an Entry from the database. True if the Entry exists in this case. It is deleted. Okay. Das heißt, wir holen uns wieder den User. Okay. Dann sagen wir If User Entries Filter Was haben wir denn? Der EntryName, ja. Okay, das war nicht. EntryDeleted Dann True Else False Okay. Compose a string of all entries as a padded table. Extend a given string with spaces The text to extend How long the final string should be. True if spaces are added at the front, false if spaces are added at the back. Okay. Front Dann wollen wir vorne Spaces anfügen. Ja. Genau. Am liebsten wollen wir sie hinten anfügen. Sieht auch gut aus. Okay. Compose a string of all entries as a padded table. CurrentUser User haben wir ja dann schon. Brauchen wir das gar nicht. Nicely formatted a string of all entries of that user in the following format. Let n be the length of the longest value in the name column. Let n be the length of the longest value in the name column. Let s be the two spaces. Wie bitte? Let e be the entries. Then compose the following table. Hier ist dann wohl schon richtig formattet, I guess. Ah, okay. Dann haben wir hier den längsten und dann paddelt man alle auf diese Länge. Und zwar paddelt man die names front. Ok, das heißt, wir haben erst mal die entries. Und dann wir brauchen longest name. Was tut es hier? Lambda Egg. Egg sind dann alle Einträge oder sowas, I guess. Hä? Zu wenig klare Pfeifensyntaxen. Ok, aber I guess es tut schon das Richtige. Brauchen wir die longest mail. Ja. Ok. Let s be the two spaces. Ah, ich hab einmal hier two spaces davor. Ok. Das heißt, ich sag jetzt Egg rigged und dann sag ich four machine entries. Das hier oben meckert auf jeden Fall schon. Ok, es sagt aber nur, dass der Name double defined ist. Das ist glaube ich egal. Pfff. Zu viel Maus. Ok. Zwei leere Dinge. Name. Pad the name with spaces at the back. Hä? Aber der hieß ja nicht spaces at the back padded. Seltsam. I guess. Padstring den Name nach longest name.