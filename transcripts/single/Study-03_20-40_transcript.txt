und gretanen true. deleteEntry, colon runs den Entry, wenn der Entry entzündet, deleten wir ihn, getEntry.june muss eigentlich passen. getEntry passt auch. ob ist die datenbank persistent? wer weiß. nein. ist sie nicht. dann machen wir wieder ein neuen User. und dann loggen wir das ein. das heißt, dass er nicht persistent ist, das heißt wahrscheinlich, dass es nicht kombiniert wird in der Session. dann muss man das wohl auch gleich noch machen. gucken wir erstmal, ob wir Entries hinzufügen können. nein. warum? kann ein User das Entry existiert? eigentlich. das funktioniert doch auch bei... das kann doch auch hier funktionieren, so dass er sich da nicht beschwert. was genau ist ein Instrumented List Attribute? was ist das? eine Relationship? das heißt... was gibt es da für Filter? dann gucken wir mal nach, was SqlTerminates sagt zu Relationships, die man da auf die Form kassieren kann. und zwar, wenn wir eine Relationship haben, dann kann ich... wie komme ich jetzt hoch? ok. das ist nur, dass niemand es aufbaut, aber es liegt im Prinzip hier. Terminates... nein, das ist auch nicht anders. was ist ein Instrumented List? Interessant. wenn wir eine Relationship haben, dann kann ich dazu zugreifen und filtern. laut der Dokumentation. warum funktioniert das hier nicht? ist das ein anderes? nein. User, Filter. currentUser. currentUser, Filter. warum geht das nicht? ähm... postUser, äh... wir können da was entfernen, wir können da was removen, wir können... wir können da was entfernen, wir können da was removen, wir können... wo ist denn das AddEntry? ist das, weil das Entry ist? ist das das Problem, dass die leer sind? das ist die Stelle, an der wir hängen. ähm... wir können... wir können bei Testing User Entry... nein, das wird auch nicht funktionieren. userEntry und äh... das ist äh... ähm... testen wir das nochmal. neuer User. Test, Test, ähm... ein Test, Test. wir kreieren einen Entry. ein Test, Test, Test. und da funktioniert es. das heißt, es ist tatsächlich so, dass die Liste, wenn sie leer ist, nicht... äh... funktioniert. Sehr schön. funktioniert. ähm... wenn wir... jetzt... quitten... ist die Datenbank aber weg. das heißt... nach... all dem hier, will ich Session.Connect machen, glaube ich. ähm... rescueAlchemy... gucken wir nach, ob das... äh... dass das ist, oder ob das nur dafür ist, wenn ich Objekte bearbeitet habe. ähm... was das mit Session tun? ja, genau, doch, wir müssen das connecten. ok. ähm... dann fügen wir den Connect Call... mal überall da ein, wo wir Sachen hinzufügen. ähm... wo haben wir noch sowas? getEntry, updateEntry, da kommitten wir schon. ich glaube, das ist nur neuer User und neuer Entry. ok, rerun. ähm... neuer User. Test, Test. ok, dann quitten wir mal. dann gucken wir mal nochmal, ob es jetzt drin steht. Test, Test. und es steht jetzt drin, sehr schön. dann fügen wir ein Entry hinzu. und dann... jetzt muss ich die Entries mal anzeigen. ähm... schau, ein Entry, den nennen wir Test. das funktioniert auch nicht, anscheinend. ok, cool. ähm... warum funktioniert das nicht? der User müsste doch mittlerweile Entries haben. und DMs existiert haben. ähm... der User hat immer noch getestet, der gleiche Fehler. dass das nicht existiert. dann probieren wir das einfach auch nochmal mit der Zwischenebene. dass wir uns den Zwischenfall dann... ja, das ist kein Problem. äh... dann machen wir das. vormarkieren wir das mit... genau, mit Refactoring. ähm... und dann... probieren wir das nochmal. getEntry ähm... wenn wir... wenn der User das hat, dann returnen wir den... äh... return None. das war vielleicht sogar unnötig, aber... machen wir mal, dann... gucken wir nochmal, ob das funktioniert. Login, Test, Test. so, und dann schauen wir uns mal die Liste der User an, der Anträge an. das funktioniert. zweitens, wir wollen... äh... den Entry mit dem Namen Test. das funktioniert nicht. warum funktioniert das nicht? das ist doch... das... gleiche... was ich im Endeffekt... hier mache... ähm... diese Entry... ah, das hatte eben noch nicht existiert. das ist dadurch, dass ich das umschippe. ähm... das ist interessant. das... äh... das geht auf Codefinite, das ist vorgeschlagen, aber hier ist Codefinite anscheinend, keine Ahnung. äh, an der Stelle... äh... hab ich... hat es zugemacht. was war denn das? ähm... hier Alchemy... äh... Alchemy... äh... Instrumentalist. was ist... ja, genau. Stack Overflow. das... ist die... äh... das ist was, was Instrumentalist ist. äh... in order to work with relationships as a query, you need to configure it... aha, Dynamic Relationship. okay. oder... das kann ich bestimmt auch... auslesen, ohne... äh... das... gucken wir mal, was... das gleiche muss sein. ja, wirklich, das gleiche. okay. ähm... wo... macht der das jetzt? macht der das irgendwo? die Relationship... äh, den Atomformel müssen. Querying Items. ähm... und zwar... One-To-Many Collections. ähm... das ist alles. One-To-Many Collections. Update Delete. One-To-Many Collections. Session Execute. Existing Countryside State. Kann ich die nicht in die Query-Galley denn? Creating Querying Items. Querying Items. Ja. Äh, right on the top. Okay. Ähm... Querying Items. Existing Countryside State. Collect. Where. Das heißt, ich muss da tatsächlich... ähm... ein SQL-Code schreiben. Session.scalars. Was macht dieses Session.scalars? Äh... Use Select Construction. The company that you need more... using the Session.scalars method that will return... a result that yields or only directly where... determined in the debit account. Limit 10 to retrieve only a few tens of rows. Okay. Aber ich... hab ja keine... Large Database. Eigentlich müsste ich... Äh, kann es sein, dass... Wo ist die Dokumentation? Ähm... SQL-Viewer. Äh, ähm... Aha. Krieg ich jetzt die Datenbank da wieder rein? So, wie sieht die denn jetzt aus? Wir haben... einen Entry und einen User. Und... der User hat keinen... Der müsste doch auch einen... Ich dachte, die haben einen neuen Rechenschiff und ich dachte, der... glaubt in der Datenbank auch. Ah, der hat hier die User-ID. Wie zieht man die so rum? Ähm... Updated er das nicht automatisch? Dann... Doch, macht er ja. Er kann es ja nachgucken. Doch, doch, doch, doch. Macht er. Ähm... Das heißt, wenn ich... das Filter... Ist das Problem tatsächlich dieses... Count transactions... Removing items... Ja, ich will aber Items haben. Ähm... Is that the right one? Okay. The statement generates... Ja. Schön. Ähm... Write... It's not just write-only-collected. Warte mal, ich hab doch nicht nur write-only-collected. Kann doch mit Sicherheit auch host-items... Sorry. Ähm... Okay. Write-only... Ähm... Was hat... Was sagt denn der auf die rassigen Kommentare? Der weiß ja gar nichts über die. Der... hat doch ein sehr ähnliches... Setup, oder? Ja, genau, so ist es. Nee, der hat ein bisschen mehr Zeit. Ähm... Wenn man das gleich spüren möchte, dann... mit etwas wie backreference. Okay. Without lazy-dynamics you get a regular sort. But this doesn't need to translate to me. Kann da base-query, you can do stringful, I don't give a crap about query. Das ist nicht das, was ich will. How to work with a relationship as with query. Okay. Was? Muss man die konfigurieren? Darf ich die konfigurieren? Ähm... Ich meine, das Einfachste... ist... äh... Wie sagen... Hat die eine... Hier, ein lazy. Ich meine, man kann einfach ein Medienfilter reinschreiben. Kann ich das richtig sehen? Ähm... Instrumentalist. Aha, da sind wir doch jetzt bei dem Typ, der tatsächlich Sachen macht. Äh... Instrumentalist wird ein Bild ins Set. Oder äh... Ja. Ich meine, das ist nicht sicher. Aber das hilft mir nicht weiter. Toll. Äh... Muss ich vielleicht... Kann ich? Ist das callable? Kann es sein, dass ich einfach... Dass das da funktioniert? Ähm... Mal probieren. Ähm... Loggen wir das ein. In Thumbnail natürlich. Ähm... Test. Test. Ähm... Was wäre das AppEntry? 3. Nein, das ist natürlich nicht callable, um es aufzulösen. Okay. Ähm... Also... Ja. Packings wären echt cool. Ähm... Funktioniert das? Nein. Keine Ahnung. Ähm... Wir müssen vielleicht... Ich glaube, das wäre nicht so eine gute Konfiguration. Okay. Lassen wir das einfach so sein. Ähm... Second word, was war das da? Oh, da steht ein Kokoledecker drauf. Cool. Ähm... Ich glaube, ich habe vergessen, den Call wieder wegzumachen. Ähm... Show entries. Ähm... Okay. Das funktioniert jetzt so. Ideal. Ähm... Ja, okay. Dann... Gucken wir mal noch, ob wir Sachen editieren können. Ähm... New Entry. Ähm... New Name. Test 2. New Info. Test. Impasse bleibt. Okay. Dann zeigen wir uns, dass wir das Ding nochmal anfangen. Und es funktioniert. Ähm... Verschieben wir mal noch einen Eintrag. Das hat auch funktioniert. Lass mal... Was passiert, wenn ich einen Eintrag lösche, der nicht existiert? Darf man das da auch nicht zu? Wenn ich etwas editieren will, was nicht existiert. Lecker da auch. Ausloggen geht. Quicken geht. Ich würde sagen, es funktioniert. Was sagt die Dokumentation jetzt dazu, schönes? Ähm... View List of Entries. Das funktioniert. Particular Entry. Auto-Authenticator. Das hat funktioniert. Add a new Entry. Funktioniert. Add a new existing Entry. Funktioniert. Add a new existing Entry. Funktioniert. Ähm... Okay. Ähm... Können wir noch einen Test schreiben. Für das Ganze. Jetzt darf man da vorne vielleicht ein bisschen löschen. Ähm... Python-File. Test. Äh... DEP. Test. Add. Gibt es da Text? Text. Kann man nicht mit dem Package machen. Na, vielleicht bald. Ähm... Weiß. Äh, GitHub-Profile. Das geht. Ähm... Test. DEP. I. Nee, DEP. Add. User. Ja, nee. Du sollst nicht mir Kommentare schreiben, GitHub-Copilot. Du sollst mir sagen, wie das funktioniert. Okay. Ich weiß ja nicht. Schade. Dann müssen wir das nachgucken. Ähm... Uh, ja. Python-Test. For example. Ähm... Test answer. Start. Okay. Das heißt, das Einzige, was ich damit testen kann, ist das Padding. Ähm... Weil das andere bräuchte irgendwie noch einen Dattelbunker. Ähm... Dann löschen wir das mal wieder und schreiben einfach für den Padding-Test in die gleiche Klasse. Äh, in die gleiche Klasse. Ähm... Test.