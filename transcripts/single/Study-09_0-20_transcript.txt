Du machst mehrere, oder? Ja. Du kannst nicht mit deinem Handy das OBS bedienen. Ne, leider nicht. Das wäre schon krass. Aber das Mikro da ist gar nicht so toll, deswegen. Ja, mittelschön. Ja, ist klar. Dann lese ich doch mal die PDF. Ok, ToDo-Kommentare in db.py. So, probieren wir doch mal Copilot aus. Jetzt will ich hier einfach mal, dass er mir etwas vorstellt. Haha, ToDo ist natürlich ein schlechter Vorschlag. Next. Open. Ja, das sieht doch ganz gut aus. Das nehmen wir einfach mal. Und es sieht tatsächlich so richtig korrekt aus. Dann schaue ich als erstes mal, welche Funktionalität hier überhaupt direkt verwendet wird. Wir haben ein Command-Line-Tool. Dieses Command-Line-Tool, das begrüßt uns, aber dann macht es nichts. Ist das richtig? Nein. Hier gibt es bestimmt... Ah, es fragt nach Dingen und... Oha, was sind denn Queries? Faszinierend. So, ich versuche es einfach mal auszuführen. Gibt das hier? Ja. Oh, nice. Wir können uns einloggen. Nein. Doch. Hallo. Hallo. Okay, also die Funktionalität geht noch nicht richtig, denn unsere Nutzer existieren schon, obwohl das nicht wahr ist. Aber wahrscheinlich ist der Weg trotzdem, erstmal alle To-Do-Kommentare durchzugehen. So, wie funktioniert denn PyCharm? Mal schauen, kann ich hier irgendwie schauen? Find Usages. Ja, sehr gut. Was ist denn eine Session? Session. Session ist gar nichts. So, wie wäre es denn mal, weiter das Assignment zu lesen? So, wenn ich Tests schreiben will, dann mache ich das mit PyTest. Wie PyTest funktioniert, weiß ich nicht, aber ich probiere einfach mal Cooper dazu zu fragen, mir einen PyTest-Test zu schreiben. Ja. So. So. Hallo, Coopilot. Refresh. Nein, so geht das nicht. Okay, dann wollen wir vielleicht eine Funktion machen. Okay, testen klappt nicht gut, dann lassen wir das einfach mal. So, Hash ist schon implementiert. New User. Das klingt kompliziert, dafür müsste man erstmal wissen, was eine Session ist. Und die Session, die ist hier, kann ich da hingehen? Ja, hier kann ich hingehen. Und dann kann ich hier schauen, wo die gesetzt wird. Value writes. Create Session. Das ist also ein SQLAlchemySessionDing. Das heißt, irgendwo sollte es einen User geben. Dann probieren wir doch mal aus, mit Coopilot den User in die Session einzutragen. Vielleicht schafft er es ja auch schon so. Das ist jetzt nur ein Vorschlag, ich hätte gerne mehrere Vorschläge. Ja, das sieht alles gut aus. Session.add. Session.commit. Oha! Eine Funktionalität, die man sonst wahrscheinlich vergessen hätte. Das könnte so klappen. Wie komme ich denn zurück, in dem ich klicke? Name & Passwort, die ID wird automatisch vergeben, und die Einträge sind wahrscheinlich nicht vergeben. Wie kommt das hierher? Das ist eine Funktion, die ist hier. Hier ist ein Funktion, die erlaubt die Person, diese Funktion zu verabschieden. Das ist eine Funktion, die erlaubt die Person, diese Funktion zu verabschieden. Name & Passwort, die ID wird automatisch vergeben, und die Einträge sind wahrscheinlich null. Das lassen wir also so. Beim Einloggen sollten wir das Passwort prüfen. Hier ist jetzt die Funktionalität von CoPilot nicht richtig, weil der... Ah, wobei, sie ist doch richtig. Das Passwort ist ein Hash, und das Passwort werden wir gehashed reingeben. Das heißt, die Funktionen werden alle mit einem Hash aufgerufen. Das klingt eigentlich gut. Dann wirkt diese Funktionalität auch richtig, sieht mir so aus. Gehen wir einfach mal weiter. addEntry will ein User aus der Datenbank. Den geben wir aber mit currentUser rüber. Und dann wollen wir ein Eintrag... Das heißt, wir suchen erstmal nach dem Entry von diesem User. Uh, ganz viel Code, was passiert hier? Die User-ID wird geprüft und das Entry wird geprüft. Das sieht gut aus. Das sieht eigentlich alles ganz gut aus. Probieren wir das mal so aus. Ähm... Dann deleteEntry, vielleicht kann er das ja sogar auch. Session. Oder müssen wir unseren Entry zuerst holen? Entry gleich. If not Entry. Return false. Session delete. Session commit. Return true. Das sind alles schöne Zeilen, die finde ich so gut. getEntryView will... ...eine formatierte Tabelle. Die Regeln wirken mir etwas komplex. Das heißt, da sollte man dann vielleicht sogar so einen richtigen Test verschreiben. Aber probieren wir doch erstmal die KI aus. Ähm, so... Hallo? Was sagt die KI? Ähm, hier jetzt... ...rauszufinden, welche von den Computations richtig ist. Keine Ahnung. Äh, vielleicht sollte ich mir dafür den Kommentar mal durchlesen. So, wir wollen die Längen von den Einträgen alle berechnen, um die Maximale rauszufinden. Wir wollen zwei Spaces haben. Wir... ...wollen zuerst Spaces, dann Namen, dann Spaces, dann Info, dann Spaces, dann Passwort. Mit den jeweiligen Einträgen. So, wie sieht denn die erste Completion aus? Wir berechnen uns die Länge... ...von den einzelnen Einträgen... ...und mindestens vier, verstehe ich nicht, vielleicht hat das einen Sinn. Und dann gibt es da eine sehr große Expression. Das ist zu kompliziert. Nehmen wir das nächste Ding. Wir berechnen uns die Länge wieder und hier aus dem Code wird auch klar, warum das vier war. Das ist ein bisschen hübscher. Und außerdem ist der For-Loop unten, das sieht mir eigentlich nach der netteren Lösung aus. Die nehmen wir also mal, ob sie korrekt ist, wer weiß. Erstes Problem, Session.query geht nicht, weil hier keine Session übergeben wird. Was mir jetzt erstmal suspekt vorkommt, weil es mir unklar ist, ob man von dem Nutzerobjekt tatsächlich auch die Einträge kriegen kann. Probier ich das mal aus. CurrentUser. Gibt es hier irgendwie so einen? Nein, es gibt keinen. Okay, dann muss man da später wieder zurück zu kommen. Vielleicht fehlt bei der Methode ein Parameter, wer weiß. GetEntry klingt so, als könnte man das über CompilateGood autokompleten. Aber hier fehlt auch wieder die Session. Kompleten wir es einfach, auch wenn die Session fehlt. UpdateEntry hat einen Breakpoint. Und da haben wir zumindest die Session, das heißt wir können hier auch nett autokompleten. Das Ding wirkt mir jetzt zu magisch. Bin mir nicht sicher, ob der Code so funktioniert. Weil wir hier ja irgendwie gar nie explizit sagen, dass wir in der Session was verändern. Also kommt da ein TodoTestPathLessWords-Kommentar rein. Dann haben wir hier alle Todos implementiert, oder zumindest probiert. Gibt es noch mehr Todos? Kann man hier suchen? Ja, es gibt. Nein, ich weiß nicht. Vielleicht mal schauen. Wir haben keine Todos mehr. Dann führe ich es doch einfach mal aus und schaue, in welche fehlenden Session-Parameter man als erstes reinrennt. Neuer Nutzer. Hi. Hi. Wir haben einen neuen Nutzer erstellt. Kann ich mich einloggen mit dem falschen Passwort? Nein. Sehr gut. Kann ich mich einloggen mit dem richtigen Passwort? Ja. Kann ich meine Liste anschauen? Nein. Session fehlt. Tja, das ist natürlich schade so, aber die Session übergeben ist wahrscheinlich kein großes Ding. Die Session ist hier eine globale Variable, also würde ich die doch einfach mal übergeben. Und dann hier auch verwenden. Und dann ist leider der Kommentar falsch, aber vielleicht kann man den sogar updaten. Und dann mache ich das auch mal bei den anderen Funktionen, wo die fehlen. Ähm, genau. Und bei der Funktion muss natürlich jetzt auch noch die Usage geupdatet werden. Es gibt sogar zwei, oha. Und dann probieren wir den Spaß noch einmal. Aha, die Datenbank ist tatsächlich persistent. Ich habe hier jetzt einen Runtime Error geworfen. Gleichzeitig will der Code nicht, dass ich einen Runtime Error werfe, sondern dass ich Faults zurückgebe. Das heißt, da gebe ich doch lieber Faults zurück. Ähm, dann loggen wir uns doch mal mit unserem schon erstellten Nutzer ein. Wie kann ich den eigentlich löschen? Ah, ich kann den Nutzer nicht löschen. Und schauen wir diesmal meine Liste an und sie sieht vielleicht korrekt formatiert aus. Ah, wobei, checken wir das später erst, wenn wir den Passwort haben. Äh, dann kriegen wir ein Passwort hinzu. Name, Mail, Info, cd.ertf.de. Passwort, fünf Stellen, abecd.ertf. Das sind sechs Stellen, so fünf Stellen. Und dann nehmen wir noch paper mit a.ertb.com. Und dann schauen wir uns unsere Liste an. Und die sieht nicht ganz hübsch aus. Was ist denn da jetzt das Problem? Die obere Zeile... Ah, okay, da sind mehrere Dinge falsch. Probieren wir doch mal einen Test dafür zu schreiben. Wie machen wir das denn jetzt? Mal schauen, was sagt denn die Beschreibung dazu? Die Beschreibung, die scheint das nicht zu beschreiben, sondern verlangt nur Funktionalität. Ähm, haben wir hier irgendwas, was so aussieht, als würde das Tests machen? Eigentlich nicht. Wir haben einen Test.db. Oh, Gott. Ähm, aber alle Funktionalität hier, das Wort Test kommt wahrscheinlich gar nicht dran vor. Mal schauen, was sagt denn die Suche dazu? Ähm, die Suche funktioniert anders, als ich das erwartet habe. Wir suchen in... Ich will den Text durchsuchen. Text. Created by Python? Nein, das ist irgendwas anderes. Was auch immer das hier ist. Faszinierend. Ich glaube nicht, dass das von mir kommt. Ähm. Und der Rest ist auch nicht okay. Das heißt, wenn man da jetzt hübschen Code haben will, dann... Ähm. Geht man erstmal hin und zeigt die Exception an. Ähm. Und geht danach dann vielleicht tatsächlich so ein PyTest-Ding schreiben. Wie funktioniert ein PyTest? Habe ich Zeit für solche Späßchen. So, ich gehe mal davon aus, dass mir Copilot hier nicht helfen kann. Weil mir Copilot ja Completions gibt in der Datei. Und ich würde jetzt mal davon ausgehen, dass man irgendwie neue Dateien anlegen muss für seine Tests. Ähm. Aber gleichzeitig sieht das hier gar nicht so aus, als gäbe es irgendwie... Ah, doch. Test unterstrich irgendwas. Gehen wir hier also hin und...