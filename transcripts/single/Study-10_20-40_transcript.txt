Es gibt ja ein Create Session. Das ist aber bestimmt wieder irgendwo, wo ich gar nicht hin soll. Aber mal gucken. Ah nein, es ist hier. Interessant. Ah ja, das kann einfach. Einfach wieder so ein magisches Datenbankobjekt. Schön, schön. Was habe ich hier? Hier habe ich keinen User, sondern eine Datenbank-Session und muss wahrscheinlich direkt mit der interagieren. Vielleicht kann mir PyCharm hier helfen, wenn ich hier einfach Session. drücke. Achso, ah. Achso, ja, ich erinnere mich. Keine statischen Typen in Python und so. Ähm, commit. Ah, das ist schon mal ein schöner Vorschlag. Das erinnert mich an BDE, aber das will ich gar nicht. Ähm, was will ich stattdessen tun? Ich möchte irgendwie herausfinden, was Session für Einträge hat. Da das aber zu unständig ist, könnte ich PyCharm darum bitten, mal Dinge aus Session abzufragen. Oder was brauche ich? Ich brauche bestimmt deren Einträge. Ähm, get Session entries. Iterate over all entries. Vielleicht machen wir hier oben nochmal Copilot auf, was Copilot dazu sagt. Ähm, retrieving completions. Tum-di-dum-di-dum. Äh, warum auch immer er gerade so lange rechnet, das ist vielleicht kompliziert, vielleicht auch nicht. Vielleicht hat er sich aber auch nur einfach aufgehangen. Ah, hier ist was. Okay, ganz viele Kommentare, die brauche ich nicht. Entry.name. Entry ist, achso, ah, wait. Ähm, ah, the entry of, oh, ah, Gott. Hm, ja, okay, das ist viel einfacher als gedacht. Äh, ja, ich muss natürlich bloß den Entry ändern und das dann in der Session eintragen. Gut, gut. Äh, dann können wir doch hier, was war es? Hier oben habe ich doch gerade was gefunden. Äh, scroll bitte so, wie ich das möchte. Ähm, äh, das ist aber ein bisschen viel. Ich möchte im Prinzip nur das Entry.name gleich der alte Entry. Was tust du hier drüber? Get Session entries. Aber das ist meiner Meinung nach schon, wenn ich hier den Docs schon richtig verstehe, schon getan. Muss ich irgendwas zurückgeben? Nein. Also würde ich mir jetzt einfach mal das hier kopieren und sehen, ob Copilot das mag. Ja, ich brauche nicht die Session entries. Tut mir leid für die Verwirrung, Copilot. Ähm, so, commits changes, das klingt doch okay. Und dann können wir hier unten ein Return hinschreiben, was es absolut nicht bringt, aber es sein könnte. Ähm, wir könnten das ja jetzt einfach so sein lassen. Richtig testen kann ich das ja auch nicht, weil ich ja nicht unbedingt weiß, wie ich so eine Session erzeuge. So, das ist erledigt, das ist erledigt. Das ist erledigt, das ist erledigt. So, delete entry, add entry, login. Ah, login ist wahrscheinlich das, was ich brauche, um gleich zu testen, weil... Ja, pad string, extend to given string with spaces, hab ich glaube ich schon erledigt. Vorausgesetzt, diese lustigen Methoden klappen hier gleich. Aber da PyCharm sagt ja, bzw. da PyCharm Documentation dafür anzeigt, gerade zwar nicht, aber vielleicht, wenn ich hier nochmal reinklicke. Ah, ach so, witzig, ljust gibt es, rjust tut aber nichts. Ah, wir werden gleich sehen, ob Fehler fliegen. Ähm, pad string brauche ich wahrscheinlich gar nicht. Oder was tut es? Extend to given string with spaces. Ah, so, okay, da kann man also herausfinden, wie das ist. Ich bin jetzt neugierig, ob diese Funktionen funktionieren, weil das würde mich schon interessieren. Session, the dbSession object. So, ähm, the user's name, the user's password as a hash. So, return the user object if the user exists and thus can be logged in as none. Also, wir versuchen mal, was dieses Session object kann, bzw. fragen wir mal Copilot danach. Ich liebe diese Vorschläge. Log in user, ja, into Session. There we go. User.Session.Query.User.Filter. Äh, okay, das gibt mir den User, korrekt. Ah, ach so, und das könnte, wie ist das, was ist denn das First von einem Filter? User.Session.Query. Boah, da habe ich jetzt ehrlich gesagt gar keine Ahnung, ob das richtig ist. Mal sehen, ob mir PyCharm jetzt sowas anzeigt. Filter.User.Name.Gleich.Name.User.Password.Gleich.Password. Punkt. Ach so, aber das ist die Filter-Methode von diesem gequerierten Object da. Ach, wir schauen einfach mal, ob es das tut. Und, äh, iflen von User. Äh, was ist das? Gleich, gleich, null, return null. Korrekt. Ähm, und sonst? Möchte ich bestimmt irgendwelche wilden Dinge mit diesem User tun, oder? Session.Db.Session. Also langsam kann ich mir tatsächlich überlegen, ob ich mal Dokumentation lese. Ähm, ah, Sekunde. Ach so, ich soll ihn gar nicht einloggen, ich soll ihn nur zurückgeben. Ah, dann ist natürlich die Frage, denn die Datenbank speichert bestimmt nur gehashte Passwörter. Also muss ich mein Passwort erst hashen. Also, HashPassword, die existiert ja zum Glück schon, und hier Password. So, und jetzt? iflen User gleich null. Und dann return ich non. Und sonst? return User. Hoffentlich kommt die Sprach-zu-Text-AI damit klar, dass ich hier so denglisch schaue, aber okay. Ähm, so, ach, das... Ah, damit könnte Login funktionieren, aber da ich aber new User noch nicht implementiert habe, kann ich ja keine neuen User anlegen. Und es passieren bestimmt genauso komische Dinge wie eben. Also irgendwie muss ich sofort false zurückgeben, wenn da schon ein User mit dem Namen existiert. So, dann nehmen wir doch das hier von hier unten. Oh, na dann. Schauen wir das ja doch mal an. Das sieht genauso aus wie das Query, nur dass ich nicht nach einem Passwort frage. Das ist, glaube ich, korrekt so. Wenn User angleichen und return false. Ja, weil wenn es schon User mit dem Namen gibt, will ich ja false zurückgeben und gar nichts tun. Add User to Database. New User ist User mit Name. Und Passwort ist das gehashte Passwort. Ja. So, dann Session.add. Warum auch immer man den hier einmal adden muss und hier unten nur committen. Achso, weil der end-Shield bestimmt schon existierte und der bestimmt irgendwie weiß, dass das zu der Datenbank gehört oder umgekehrt. So, dann möchte ich den User zu der Session adden, committen und true machen. Also add true zurückgeben. Drücken wir doch mal Tab. Was tut PyCharm hier? Shadows the name New User. From OtaScope. Wo ist der New User? PyCharm, bitte sag mir, wo New User ist. Wir nehmen das Element MoreAction. Add Typein for New User? Nein. Suchen. New User. Oh, ups. Das ist der Funktionsname. Okay, das hätte ich selber herausfinden können. Achso, New ist schon sowieso als Keyword. Ich suche gerade einen neuen Namen. Also New ist sowieso schon belegt. Also New ist sowieso schon belegt. New Use ist absolut missverständlich. Ich mache jetzt aber eine Eins dahin, oder? Ich mache jetzt eine Eins dahin. Meine Mitprogrammierer würde es freuen. Zum Glück bin ich hier nur mit Copilot unterwegs und nicht mit jemand anderem. Okay, mal gucken, was passiert, wenn ich hier ausführe. Ich würde gerne einen New User anlegen, korrekt? Create a New User. Okay, ich bin immer noch Tim, wenn ich mich richtig erinnere. 2, 3, 4. Oh, ja, sehr schön. Object of Non-Type, aha. Eine Fehlermeldung, sehr schön. Object of, wo ist das? Line 39. Blub, blub, blub, blub, blub. Non-Type has no LAN. Aber das hier schon Non zurückgibt. Uh, das ist interessant. Ah, oh. Ja, weil First ist bestimmt deren erstes Objekt. So, wenn ich jetzt also nicht First hinmache. Ah, ich checke hier auf Non. Das ist wahrscheinlich... Wie macht man das noch? User... Stop, warum hat... Jetzt ist es gerade durch die Gegend gesprungen. Hat Copilot irgendwas verändert? Nein, es war nur so... Ah, wahrscheinlich hat es Completions eingefügt. If User gleich gleich Non. Aber eleganter ist es eigentlich, wenn ich nur User schreibe. Nein, if not User. Egal, ich mache jetzt hier einen gleich gleich Non hin. Ich entschuldige mich hiermit im Voraus für meinen Programmierstil. If User gleich gleich Non. Was sagt PyCharm da drin? Perform with equality operators. Replace equality. Ja, ist okay. Ja, finde ich gut. Das muss ich hier unten wahrscheinlich auch fixen. So, LAN von User. Ich möchte hier dann hier erst das First zurückgeben. Und dann hier das so machen. Mal gucken, ob es jetzt funktioniert. New User 2. Tim. Und 1, 2, 3, 4. Error. User with Tim already exists. Das liegt bestimmt an der Create New User. Dass die zu früh vor ist, zurück gibt. Oder? User, User.session query. If User ist Non. Ach, Knoten im Hirn. Is not Non. Ich meine, es hätte Copilot eben auch vorgeschlagen. Da hätte ich natürlich einfach auf es hören können. Stop. Aborted. Ja, sehr schön. 2 new User. Tim. 1, 2, 3, 4. Success! Yay! Login. Auf Tim. Dann 1, 2, 3, 4. Ha! Sehr schön. Query has no LAN. Das ist doch genau das gleiche wie eben auch. Zeile 60. If User is... Hey! Stop. Das kein LAN hat, aber ich einen Punkt First machen kann. Das ist ja ungünstig. Wie hatte ich das eben getan? Ich hatte... Moment. Hä? Ah, da. Ich hatte das First schon genommen. Ja, okay. Das kann ich ja. Hier das First nehmen. Dank Copilot. Dann... If... User is Non. Return Non. Gemoppelt, gemoppelt. Ah, nein. Ich return einfach den User. Return User. Dann mal gucken, ob es jetzt funktioniert. Jetzt hat die Datenbank das gespeichert. Ich kann es ja einfach mal probieren. 1, 2, 3, 4. Ah! Logged in successfully. Das war auch das, woran es gerade gescheitert war. Okay. Dann... Viewlist 1. Enter. Name, Info, Password. Ist das korrekt? Das sieht erstmal korrekt aus. Ich habe ja noch gar keine Entries. Mhm. Show Entry, Add Entry, Edit Entry, Delete Entry oder Log Out oder Quit. Was habe ich davon schon implementiert? Naja, nichts sinnvolles. Natürlich habe ich wieder mit genau dem Falschen angefangen. Aber na gut. Immerhin bin ich bisher vorangekommen. Dann mache ich hier mal Quit. Oder Log Out. Ich mache Quit. Vielleicht muss ich mich dann nicht wieder einloggen. Ähm. Add Entry. So. Was haben wir hier? Wir haben ein... eine Session gegeben. Ein User, who is currently logged in. Okay. Wir haben ein Entry Name, ein Entry Info, ein Entry Password. Okay. Zuerst einmal müssen wir hier nochmal if there is already an Entry with that name for the current user. Das hatten wir doch hier unten schon mal gecheckt irgendwo. Bestimmt. Get Entry View. Na. Das war es nicht. Get Entry. Äh. Update Entry, Get Entry. Hä? Hatten wir das nicht irgendwo? Ähm. Wo hatten wir es? New User, User, Session, Query, Filter, wie auch immer. Nein, nein, nein, nein, nein. Das ist es nicht. Lustig. Hä? War das nur ein Vorschlag oder verwechsel ich da jetzt irgendwas? Ähm. Add Entry. Wenn ich jetzt einfach hier hin check if Entry already exists. Ja. Co-Pilot, vielen Dank. For e in current user .Entries. Ja, das ergibt auch Sinn. Da bin ich mir sogar sehr sicher. If i.name gleich name returns false. Sehr schön. Ja. Ich würde jetzt sagen, dass genau das wollte ich auch machen. Wollte aber wissen, ob es eine schnellere Variante gibt. Aber das klingt sicherlich wie eine Ausrede. Add new Entry to Database. New Entry ist gleich Entry. Okay, dass der Constructor von einem Entry, der sonst immer Klein-Entry heißt, jetzt Groß-Entry heißt, ergibt natürlich total viel Sinn. Ähm. Und wir wissen ja auch schon, dass wir den Entry irgendwie mit der Datenbank verlinken müssen. Aus dem Update. Meiner Meinung nach. Ja, wissen wir. Und deshalb macht es auch Sinn, weshalb der Entry den User kennt unter dem Namen User. Würde ich mal als Plausibel ähm äh, abstempeln. Session. Add new Entry. Wie funktioniert das? Wir mussten den User mussten wir dort adden. Ähm. Es macht vielleicht auch Sinn, also macht es sicherlich auch Sinn, den Entry dort zu adden, aber wahrscheinlich muss die Datenbank irgendwie herausfinden, ob das jetzt ein Entry oder ein User ist, der dort geaddet wird. Aber das kann bestimmt die Session. Wir sind da mal gut, glaube ich. So. Session. Commit natürlich noch. Und dann möchte ich als letztes Return true machen. Ha! Als hätte es mich gehört. Ähm. So. Add Entry. Das können wir jetzt aber testen. Bin ich noch eingeloggt? Schade. Nein. Login. Eins. Tim. Eins, zwei, drei, vier. Ha! Add Entry. Drei. Drei. Name new Entry. Test. Natürlich. Info. Dies ist ein Test. Eintrag. Bitte richtig schreiben. Ist das richtig? Bestimmt. Passwort. Ähm. Wir nehmen mal äh 0987. Muss ich mir ja nicht merken, weil dafür ist dieser Passwortmanager ja da. Sehr schön. Ähm. Zwei. Show Entry. Ah nein. Ich möchte erst die Liste gucken. Ähm. Info. Dies ist ein Test Eintrag. Das hat natürlich schon wieder bombastisch geklappt, aber vielleicht ist da der String ein. Ist ja. Ähm. Wie war das? Ich bin der Meinung hier. The length of the longest value in the name column. Including the caption info. Also. Ist das? Denke ich. Also. Meiner Meinung nach mache ich das richtig. Es sieht aber nicht so aus, wie hier steht. Oder? Also. Wie wäre das, wenn wir hier length of longest value in the name column. Ist hier pay poll. Also sechs. Und wir machen hier ähm äh padded with an info with spaces to an info at the front. Und das sind eins, zwei, drei, vier, fünf, sechs, sieben, acht. Also. Würde ich jetzt mal überhaupt nicht vertrauen. Den Beispiel und meine Intuition. Und mach hier mal nicht ein info draus. Äh. Äh. Sondern. Mach hier mal nicht die Länge des Namens. Sondern es ist der Info draus. Das hätte auch Copilot eben vorgeschlagen. Ähm. Len von. Ah. Mist. Info gibt es nicht. Wahrscheinlich muss ich dann. Wo ist das mit dem current user Punkt. Name. Mal gucken, was der User hier noch für Einträge hat. Ähm. Ich habe hier ein User. Wait. Moment. Was? Ich habe ein. Ich habe Names. Ich habe Passwords. Ich habe Entries. Nichts davon steht. Da steht irgendwo Info dran. Was soll denn das?